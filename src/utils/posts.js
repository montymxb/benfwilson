// Auto-generated file - do not edit manually
// Run 'npm run build-posts' to regenerate

export const posts = [
  {
    "slug": "attiny-getting-started-and-flashing",
    "title": "Getting Started with the ATTiny13 & 45",
    "date": "2026-02-12",
    "excerpt": "Getting started with writing & flashing to an ATTiny 13 & 45 microcontroller.",
    "content": "Custom prototyping board for building dioramas with suitable components, circuitry, and monitoring capabilities.\n\nWe're going to start small w/ that ATTiny, and the first step is being able to program the thing correctly, so let's start w/ that, and I can power it externally for now w/ this little breadboard power supply while I'm testing things out.\n\nAnd this might be suitable to write up on my own website as a learning experience too.\n\nI've been pretty interested in building up dioramas over the past few years, with a bit of increasing complexity on each following year. Most of it is a creative outlet, an enjoyable form of self-expression, but another part is also technical. In particular I'm quite interested in adding lights, servos, and connectivity (where it makes sense) to take a diorama into a slightly more interactive space. Again, there already exist solutions for this kind of thing, but the last part is that I'm using this as a learning experience too. By starting with a standalone microcontroller chip (ATTiny for now), I can experience the joy & excitement of watching the whole system come together piece by piece.\n\nThere will _definitely_ be mistakes during this process, and that's both intended and embraced. I'm very much looking forward to seeing where the project takes me, what I learn along the way, and the experience as a whole. The end goal is practical in nature, so that I can have a custom-built prototyping board that I can utilize in other projects down the road, but it's very much about the journey at this stage.\n\nAnyways, for starters we're going to get a simple ATTiny45V-10PU (in an 8-pin DIP package) setup with the all too classic _hello world_ example for microcontrollers. That is, a flashing LED. This will also save me the effort of figuring out later on whether I zapped the chip by accident while handling it, as I may or not have been using proper ESD protection at the time. Fingers crossed in that regard.\n\nI'm not particularly fixed to using just this microcontroller (I have several other ATTiny variants, plus one or two from other brands), but it's one of the smaller simpler ones I have around. It also happened to be at the top of my parts box, and I don't have any pressing need (yet) to start comparing the differences between boards. Quite frankly I don't even _know_ exactly what I'll be needing, as I only have a rough idea of where this project will go. Starting with something concrete gives me a spot to work from, and to later compare practical experience with what I could be getting from available alternatives.\n\nSo, for starters, I needed to familiarize myself with the board, sure I bought it and already knew what I was picking up _generally_ speaking, but I hadn't yet dove into it in detail. I don't intend to go too far in this first step, but I do want to:\n- program the ATTiny\n- toggle a LED on some IO pin for verification\n- _maybe_ read out on Serial back once we're done\n\nAgain the flashing LED is very much a \"hello world\" example, but also a simple way to ensure that at least the chip is good to go, and isn't toast. It also gives me a way to verify that I've got a working setup to program AVR microcontrollers. So let's get into that part.\n\nBeyond knowing what kind of chip you're building for, you'll also need the avr toolkit. You can flash these chips using an Arduino as an ISP (assuming it's got an AVR chip in it), or also with a regular AVR programmer. For this case I'll just be working with a dedicated AVR programmer, assuming that works out as expected.\n\nI _have_ thought about exploring programming these boards in [Zig](https://ziglang.org/) rather than C, as I've been picking that up in my spare time. I've always had a soft spot for C (and a bit of C++, but less so), but I don't miss the footguns. I was more interested in the direction of Rust, which is an _excellent_ language in terms of safety (especially with the borrow checker), but I'm finding I naturally gravitate towards a lower level of abstraction. In that sense, the way Zig exposes lower level constructs -- such as making safety checks a present but optional aspect of the language design -- fits what I'm looking for. This isn't to suggest that it's inherently better or worse, it's just a subjective & stylistic preference on my end.\n\nBack onto the topic of `avrdude` & `avr-gcc`. A couple of years ago I was working with ATTiny13 and an ATTiny16 on a separate project. I toasted the '13 sadly, but I was able to get the '16 working as a near drop-in replacement. During that process I took quite a few notes about how to get thing setup, wired & programmed.\n\nFor starters, we're going to need to lookup how to get started with setting up a simple test program for the ATTiny. Thankfully, there's an abundance of tutorials on how to get setup with writing, building & flashing for AVR microcontrollers. For our case here we just want a simple program to start with\n\n```c\n#include <avr/io.h>\n#include <util/delay.h>\n\nint main()\n{\n\t// set pin PB0 on ATTiny45 as output\n    DDRB |= (1 << PB0);\n\n    while (1)\n    {\n\t    // toggle PB0 every 1 sec\n\t    PORTB ^= 0x1 << PB0;\n        _delay_ms(1000);\n    }\n    return 0;\n}\n```\n\nThis will just allow us to toggle a pin high/low every second. That's more than enough for us to wire up a LED for testing, or even just measure the output with a multimeter or oscilloscope.\n\nAlso, regarding GPIOs, we only have _6_ on this particular ATTiny. Specifically these are PB0 - PB5. The other 2 pins are GND & VCC, which makes sense. However many of these pins have alternative purposes that are part of other functions that I'll want to leverage later, such as I2C and SPI for communicating with other peripherals. With that being said, I'll plan on just using PB0 for now.\n\nIf we look at a quick diagram, we can also see where our pin is in relation to the board layout. For that we'll also need to grab a quick data sheet for the AVR ATTiny45V-10PU (or your particular variant). A quick search online will turn up numerous sources to get the manual.\n\nOnce we have that we can sketch the pinout here:\n\n```\nATTiny45V-10PU (DIP)\n\nPB5/Reset -|1 • 8|- VCC\nPB3       -|2   7|- PB2\nPB4       -|3   6|- PB1\nGND       -|4   5|- PB0\n\n```\n\nWe'll want to keep an eye on that reset pin. It's also a GPIO, but we'll want a way to reset the board without having to power cycle the thing. That may change later on, but for now that brings us to _5_ GPIOs we can work with for now.\n\nIf you're curious, we can also peek at the rest of the labels assigned to these pins, which I'll just unroll here.\n```\nATTiny45V-10PU (DIP)\n\n1) PB5 (PCINT5 / RESET / ADC0/ dW)\n2) PB3 (PCINT3 / XTAL1 / CLK1 / OC1B / ADC3)\n3) PB4 (PCINT4 / XTAL2 / CLKO / OC1B / ADC2)\n4) GND\n5) PB0 (MOSI / DI / SDA / AIN0 / OC0A / OC1A / AREF/ PCINT0)\n6) PB1 (MISO / DO / AIN1 / OC0B / OC1A / PCINT1)\n7) PB2 (SCK / USCK / SCL / ADC1 / T0 / INT0 / PCINT2)\n8) VCC\n```\n\nWe won't dive into these here, but it's good to get a general sense of which pins will be needed later on for other functionality.\n\nSo, using the program we wrote up above, we'll need to compile that using `avr-gcc` (again, assuming you're installed the related tools). I'm on macOS myself, but I may pivot to building & deploying from an Ubuntu/Debian machine if that proves problematic. But for now we can just run:\n```bash\n# assuming your program is written in main.c\navr-gcc main.c\n```\n\nAnd immediately this fails, but we've got some useful errors here, such as:\n> main.c:7:5: error: 'DDRB' undeclared (first use in this function)\n\nRight, so it looks like we're missing definitions, which we should probably double check. The extra bit we're looking for is probably related to the fact we're not targeting the right board, and getting it's associated definitions.\n\nAfter poking around a bit I recalled needing the `-mmcu=attiny13` flag before, so trying that with `-mmcu=attiny45` as a guess gives us a good build result.\n```bash\navr-gcc -mmcu=attiny45 main.c\n```\n\nThere may be a better option from the available device spec however, but for now this should suffice (we can always go back & check that later). We do have a couple warnings (at least on my side), but we'll ignore them for the moment.\n\nAt this point we should have an `a.out` present as our compiled artifact. If so, great! We can proceed to getting ready to flash this thing.\n\nFor starters, we're going to leverage `avrdude` here, specifically something akin to:\n```\navrdude -p ?? -c ?????? -P ?`\n```\nIt's full of question marks, because, well, I'm genuinely _not_ certain what we need to pass yet, so let's fill in the gaps.\n\nThe `-p` flag is used to specify the part number, which we need to lookup. We can do this pretty quickly via `avrdude -p ?` to list all available parts. Note that on my setup within zsh, I had to escape the `?` to avoid it being literally interpreted, just a small thing.\n\nGreping through that gives us an entry like so:\n```\nt45        = ATtiny45, ATtiny45V (SPM, ISP, HVSP, debugWIRE)\n```\nWhich looks spot on! So `t45` is our part.\n\nThe `-c` flag tells us which programmer we intend to use. Much like the `-p` flag, we can run `avrdude -c ?` to list all available programmers.\n\nAnd honestly, at first glance I had no idea which programmer to select. I vaguely remember having the same problem before, so I flipped back to some old notes, and saw that I was using `ft232r`, which corresponds to this entry:\n```\nft232r             = FT232R based generic programmer (TPI, ISP)\n```\n\nAgain this turned up a huge blank in my mind, so I had to look it up quickly. This was just a regular USB to Serial converter, with that particular chip being at the heart of it, which matches up.\n\nI also had a couple other AVR-based programmers that I wanted to check out too. Specifically one unmarked programmer with an `ATMega8A AU 1801` and another marked as an `AVR Pocket Programmer` by Sparkfun with an `ATTiny2313-20SU`. The later was given to me by a friend from a while ago, but I never got to put it to use. So looking it up a bit, [found a product page](https://www.sparkfun.com/pocket-avr-programmer.html), and an [accompanying github project as well](https://github.com/sparkfun/Pocket_AVR_Programmer?tab=readme-ov-file). Through that, I found that `-c usbtiny` is the write field here (makes sense given the ATTiny as the core), but I also found that it's also got a nifty power feature. This lets the programmer power the board with up to 500mA, which is super convenient. So at this point I decided to switch to the `AVR Pocket Programmer`.\n\nGreat, so from there I just need to deal with the last flag `-P` for the port. Granted we don't quite have that yet until we plug in the device, so doing that and looking through `/dev` yielded....\n\nNothing, at least not at first. I went ahead and looked it up. At this point I also noted that it was a good idea to double check that what we had to so far was correct, so running the following effectively:\n```bash\navrdude -p t45 -c usbtiny\n```\n\nAnd I was able to see the following:\n```\nError: cannot find USBtiny device (0x1781/0xc9f)\nError: unable to open port usb for programmer usbtiny\n```\n\nWhich looks pretty good for now.\n\nI also noted a _ton_ of warnings about an inability to locate expected data, ex. `Error: unable to locate ATxmega16A4U's data in multi-memory address space`. Looking it up suggested some issues with the installed AVR board package, and also with the configuration file itself. On my system, I was able to find several config files in various locations, and also I was able to feed them in via `-C other.conf`. This yielded fewer but more problematic errors, but at least seemed to suggest that perhaps the default configuration (where it is) was the issue.\n\nI noted that my installation was via homebrew, and looking that up didn't get me anywhere too quickly. So noting it here I wanted to get along to the actual flashing phase, rather than getting bogged down on a potential non-issue.\n\nLooking at the programmer, the need thing we need to do is connect the dots. I wasn't terribly familiar with the pinout here, and especially the correct orientation, but it's laid out like so on the programmer I was using.\n```\nMISO |• •| VCC\nSCK  |• •| MOSI\nRST  |• •| GND\n```\n\nSo the first thing was verifying the orientation of VCC and GND with a multimeter, and once I had that the rest of the pins fall into place pretty nicely per the pin layout above. It always helps to double check (or even triple check) your pins, as I often and _frequently_ end up with an off-by-one error with my wiring. Depending on how you make that mistake, it can be a simpler change or a whole new chip that you need to grab.\n\nAssuming that's all wired up and your programmer of choice is plugged in, you can hook everything up. One particular note about my programmer was about the board power capability. I wanted this off at first, but later on it could be particularly problematic given it's fixed at 5v power. If there's any 3.3v logic on board, that could cause some problems, assuming that's not handled correctly with a logic-level converter (which I do have around just in case).\n\nSo once that's plugged in I checked out the list under `/dev`, but upon further inspection realized that's not really needed, as `avrdude` _should_ pick up the programmer automatically.\n\nIn my case I did get a different response, but it was an error:\n```\n$ avrdude -p t45 -c usbtiny\n...\n\nError: initialization failed  (rc = -1)\n - double check the connections and try again\n - use -B to set lower the bit clock frequency, e.g. -B 125kHz\n - use -F to override this check\n```\n\nI ran again with suggested change to the clock frequency\n```bash\n$ avrdude -p t45 -c usbtiny\n```\n\nBut got the same error. So I changed up how I connected the programmer to my computer, as it was a going through a bit of overhead via a USB hub & extra cabling. Running directly attached I still got the same error however, which appeared to rule out any intermediary interference.\n\nSo I went back into reading docs, and trying to figure out the issue (while not ruling out the old programmer quite yet). But wasn't able to get too far, I _was_ expecting to see a device entry pop up in `/dev` but wasn't ever able to see one pop up. This was rather suspicious, although it did seem that despite this `avrdude` was picking up that there was _something_ connected, but not much else. So I assumed I must have missed a detail there, or I was just unaware of what the detail was in the first place.\n\nAt this point, I decided to try out the other programmers I had, without connecting to the ATTiny45, just to see how they would register. The other ATMega based programmer seemed to have a similar issue, but the FT232R based programmer _did_ register as a new entry in `/dev`, which matched up with what I was expecting. That gave me some sense that I could probably use that programmer to proceed, but now I was curious why the others weren't working as expected, so I dug further into that.\n\nBased on what I came across, not seeing a USBTiny device in `/dev` appears to be expected, as it doesn't populate a new device entry. I'm not familiar enough to do more than speculate, but it appears to be related to how it communicates via `libusb`, but I could be wrong here. Establishing this at least alleviated my concern that the problem was from the missing device, and helped me to get a sense of why `avrdude` was indicating a device was found still, but it did not resolve the programmer flashing issue.\n\nAt this point I got super stuck, and it was late, so I read up on things & tinkered for a bit.\n\n- FT232R is not the right choice (that's UART, not SPI, which is COPI/CIPO)\n- Arduino nano as programmer seems viable as well...\n\n\nSo after much digging & such, I decided to shift to using an Arduino as ISP, with a pair of Nanos I had lying around. One was viable, but the other was locked up due to something I had loaded on it years ago. I figured a good way to test ISP capability was to try and reset that other board (if it could be done). So I wired them up and gave it a shot after loading the first board w/ the ArduinoISP sketch.\n\nHowever, after much testing, I was still nowhere closer to a solution. So I took a break and stepped away for a day or so.\n\n### Coming back to Flashing\n\nThe following day I read up quite a bit more about programming ATTiny's in general, and especially about some of the 'gotchas' that tend to come up. For the most part, it seems like it shouldn't be a driver issue (but that can be investigated on another machine), and I don't believe I've messed up the pin connections. But I do have a hunch that my wires (via dupont connectors) aren't as good as I would expect them to be. That, or the chip itself is not good.\n\nI was able to test with another chip to see if that was a factor, and so far the other chip has given the same response as the first, which was:\n```\nAVR device initialized and ready to accept instructions\nDevice signature = 00 00 00 (retrying)\nDevice signature = 00 00 00 (retrying)\nDevice signature = 00 00 00\nError: invalid device signature\nError: expected signature for ATtiny45 is 1E 92 06\n  - double check connections and try again, or use -F to carry on regardless\n```\n\nThis is better than before at least, but it's still not what I want. The other thing is I probably need to 'power' the board for programming, which I did not do properly, and I wanted to investigate setting up an additional cap between power & ground to stabilize things further.\n\nWell after rewiring back to the AVR Pocker Programmer a second time around, I was able to get the device to connect correctly, and program with a flashing light! Finally. After double checking a few things, I was able to isolate it down to the power feature being set to 'off'. I was under the impression that, since I was reading voltage around ~4.7 volts on VCC, it was sufficient to allow programming to happen. _But_, it seems that I although I was reading this voltage, I may have not been getting sufficient power to flash the chip. Honestly, I'm not sure yet, but I'm keeping it as an open point to investigate in more detail later on. For now having the chip flashed is a good enough spot to stop on.\n\nJust for good measure I ran the same flash sequence on another ATTiny45 I had lying around, and it was a clean drop-in replacement.\n\nI also suspect if I switch back to the Arduino Nano as an ISP I should be able to get a similar result as well, assuming that the chip was powered up during the flashing process like before.\n\nSo with all that we should have a simple program flashed & running a little ATTiny, but not much other than that. However this establishes the groundwork we'll need for building up the program, adding components to the board, and testing them out quickly to diagnose problems as they arise.",
    "frontmatter": {
      "title": "Getting Started with the ATTiny13 & 45",
      "date": "2026-02-12",
      "tags": "[attiny, post, project]",
      "excerpt": "Getting started with writing & flashing to an ATTiny 13 & 45 microcontroller.",
      "draft": "false"
    }
  },
  {
    "slug": "new-site",
    "title": "New Site Setup",
    "date": "2025-11-26",
    "excerpt": "New site setup.",
    "content": "# New Site\n\nNew redesign after quite a few years, so I've decided to shift things over onto a different domain with a focus on project work. In particular the odds & ends that I tend to tinker with, as well as various personal interests.\n\nThis page is more or less a filler to test things out before I start adding more details.",
    "frontmatter": {
      "title": "New Site Setup",
      "date": "2025-11-26",
      "excerpt": "New site setup."
    }
  }
]

export function getPost(slug) {
  return posts.find(post => post.slug === slug)
}

export function getAllPosts() {
  return posts
}
