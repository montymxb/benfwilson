// Auto-generated file - do not edit manually
// Run 'npm run build-posts' to regenerate

export const posts = [
  {
    "slug": "attiny-getting-started-and-flashing",
    "title": "Getting Started Developing for the ATTiny13 & 45",
    "date": "2026-02-14",
    "excerpt": "Getting started with writing & flashing to an ATTiny 13 & 45 microcontroller.",
    "content": "In this post I'll go over my personal experience getting setup developing & flashing the ATTiny13 and 45 microcontrollers.\nThis is mostly a self-documented process for my own purposes, but I've decided to share it for others to follow along as well.\nI'll be writing this up as I work through things so I can capture as much of the original process as I can.\nPersonally I have an _excessive_ amount of these kinds of notes & dev logs locally, but they're in absolutely no shape to be shared.\nThis is a shame really, so I figured I would take the extra effort to just write my notes in a form that _is_ suitable for sharing in the first place.\nBeyond that I have further goals here, but for this post we're going to start small with getting setup to development.\nI just want to get to a point where I can reliably program the micrcontroller, so let's start with that.\n\nFor some background as to why I'm doing this, I've been pretty interested in building up dioramas over the past few years, with a bit of increasing complexity on each following year. Most of it is a creative outlet, an enjoyable form of self-expression, but another part is also technical. In particular, I'm quite interested in experimenting with little technical touches: lights, servos, buttons, and connectivity (where it makes sense) to bring a diorama into a slightly more interactive space. There do already exist solutions for this exact kind of thing, but the last point is that I'm using this as a personal learning experience. By starting with a couple standalone microcontroller chips  (ATTiny13 & 45 for now), I can experience the joy & excitement of watching the whole system come together piece by piece.\n\nThere will _definitely_ be mistakes during this process, and that's both intended and embraced. I'm very much looking forward to seeing where the project takes me, what I learn along the way, and the experience as a whole. The end goal is ultimately more practical in nature, I would love to have a custom-built prototyping board that I can utilize in other projects down the road, but it's very much about the journey at this stage (that'll come later on).\n\nAnyways, for starters we're going to get a simple ATTiny45V-10PU (in an 8-pin DIP package) and an ATTiny13, both setup with the all too classic _hello world_ example for microcontrollers. That is, a flashing LED. This will also save me the effort of figuring out later on whether I zapped the chip by accident while handling it, as I may or not have been using proper ESD protection at the time. Fingers crossed in that regard.\n\nI'm not particularly fixed to using just this microcontroller (I have several more ATTiny variants, plus one or two from other brands), but it's one of the smaller simpler ones I have around. It also happened to be at the top of my parts box, and I don't have any pressing need (yet) to start comparing the differences between boards. Quite frankly I don't even _know_ exactly what I'll be exactly needing, as I only have a rough idea of where this project will go. Starting with something concrete gives me a spot to work from, and to later compare practical experience with what I could be getting from available alternatives.\n\nSo, I needed to familiarize myself with the board, sure I bought it and already knew what I was picking up _generally_ speaking, but I hadn't yet dove into it in detail. I don't intend to go too far in this first step, but I do want to:\n- program the ATTiny\n- toggle a LED on some IO pin for verification\n- _maybe_ read out on Serial back once we're done\n\nAgain the flashing LED is very much a \"hello world\" example, but also a simple way to ensure that at least the chip is good to go, and isn't toast. It also gives me a way to verify that I've got a working setup to program AVR microcontrollers. So let's get into that part.\n\nBeyond knowing what kind of chip you're building for, you'll also need the avr toolkit -- specifically `avrdude` and `avr-gcc`. You can flash these chips using an Arduino as an ISP (assuming it's got an AVR chip in it), or also with a regular AVR programmer. For this case I'll just be working with a dedicated AVR programmer, assuming that works out as expected.\n\nI _have_ thought about exploring programming these boards in [Zig](https://ziglang.org/) rather than C, as I've been picking that up in my spare time. I've always had a soft spot for C (and a bit of C++, but less so), but I don't miss the footguns. I was more interested in the direction of Rust, which is an _excellent_ language in terms of safety (especially with the borrow checker), but I'm finding I naturally gravitate towards a lower level of abstraction. In that sense, the way Zig exposes lower level constructs -- such as making safety checks a present but optional aspect of the language design -- fits what I'm looking for. This isn't to suggest that it's inherently better or worse, it's just a subjective & stylistic preference on my end.\n\nBack onto the topic of `avrdude` & `avr-gcc`. A couple of years ago I was working with ATTiny13 and an ATTiny16 on a separate project. I figured I toasted the '13 sadly, but I was able to get the '16 working as a near drop-in replacement. During that process I took quite a few notes about how to get thing setup, wired & programmed.\n\n_Just an aside_, much later in this process I went back to that very board with '13 on it, and pulled it off with a hot air gun just to check it _one more time_. And it actually still worked! Either I completely overlooked something before, or crosswired something on the board it was attached to, but either way it was an extra chip on hand that I didn't expect to have.\n\n### First Program\n\nSo, for starters, we're going to need to lookup how to get started with setting up a simple test program for the ATTiny. Thankfully, there's an abundance of tutorials on how to get setup with writing, building & flashing for AVR microcontrollers. For our case here we just want a simple program to start with\n\n```c\n#include <avr/io.h>\n#include <util/delay.h>\n\nint main()\n{\n\t// set pin PB0 on ATTiny45 as output\n    DDRB |= (1 << PB0);\n\n    while (1)\n    {\n\t    // toggle PB0 every 1 sec\n\t    PORTB ^= 0x1 << PB0;\n        _delay_ms(1000);\n    }\n    return 0;\n}\n```\n\nThis will just allow us to toggle a pin high/low every second. That's more than enough for us to wire up a LED for testing, or even just to measure the output with a multimeter or oscilloscope.\n\n#### An aside on GPIOs\n\nAlso, regarding GPIOs, we only have _6_ on both the ATTiny13 & 45. Specifically, these are PB0 - PB5. The other 2 pins are GND & VCC, however many of these GPIO pins have alternative functions that I'll want to leverage later, such as I2C and SPI for communicating with other peripherals. With that being said, I planned to start with PB0.\n\nIf we look at a quick diagram, we can also see where our pin is in relation to the board layout. For that we can grab the data sheet for the AVR ATTiny45V-10PU, the ATTiny13, or any other particular variant. A quick search online will turn up numerous sources to get the right datasheet.\n\nFrom the datasheet we can sketch the pinout here:\n\n```\nATTiny45V-10PU (DIP)\n\nPB5/Reset -|1 • 8|- VCC\nPB3       -|2   7|- PB2\nPB4       -|3   6|- PB1\nGND       -|4   5|- PB0\n```\n\nWe'll want to keep an eye on that reset pin. It's technically a 'weak' GPIO (not entirely sure what that means, but it's stated in the datasheet & I'm assuming we just can't drive much with it), but we'll want to retain a way to reset the board. That need may change, but for now that brings us to _5_ GPIOs we can work with.\n\nIf you're curious, you can also peek at the rest of the labels assigned to these pins, which I'll unroll here.\n```\nATTiny45V-10PU (DIP)\n\n1) PB5 (PCINT5 / RESET / ADC0/ dW)\n2) PB3 (PCINT3 / XTAL1 / CLK1 / OC1B / ADC3)\n3) PB4 (PCINT4 / XTAL2 / CLKO / OC1B / ADC2)\n4) GND\n5) PB0 (MOSI / DI / SDA / AIN0 / OC0A / OC1A / AREF/ PCINT0)\n6) PB1 (MISO / DO / AIN1 / OC0B / OC1A / PCINT1)\n7) PB2 (SCK / USCK / SCL / ADC1 / T0 / INT0 / PCINT2)\n8) VCC\n```\n\nAgain if this is for the ATiny13 or another ATTiny 8-pin variant, the pinout is likely to be pretty similar.\n\n### avr-gcc\n\nUsing the program we wrote up above, we'll can compile that using `avr-gcc` (again, assuming you're installed the related avr tools). If you haven't already, and you're on mac, you use homebrew with [homebrew-avr](https://github.com/osx-cross/homebrew-avr). If you're on Ubuntu or another Debian-like system, you can use:\n```bash\n# get avr-gcc compiler setup\nsudo apt-get install gcc build-essential\nsudo apt-get install gcc-avr binutils-avr avr-libc gdb-avr\n\n# get avrdude for flashing later\nsudo apt-get install libusb-dev\nsudo apt-get install avrdude\n```\n\nFor Windows it looks like you can pull the compiler from [microship's website](https://www.microchip.com/en-us/tools-resources/develop/microchip-studio/gcc-compilers) directly, and a pre-built release can be retrieved for [avrdude](https://github.com/avrdudes/avrdude).\n\nAlright, assuming we have the compiler in place, we can compile it like so:\n```bash\n# assuming your program is written in main.c\navr-gcc main.c\n```\n\nFor me, this immediately failed, but I got a useful error:\n> main.c:7:5: error: 'DDRB' undeclared (first use in this function)\n\nRight, so it looks like we're missing definitions, which we should probably double check. What we're looking for is probably related to the fact we're not targeting the right board, and therefore getting its associated definitions.\n\nAfter poking around a bit I recalled needing the `-mmcu=attiny13` flag before to specify the targeted microcontroller variant, so trying that with `-mmcu=attiny45` (or `-mmcu=attiny13`) as a guess gives us a good build result.\n```bash\navr-gcc -mmcu=attiny45 main.c\n```\n\nThere may be a better option from the available values for the mcu, but for now this should suffice (we can always go back & check later). I do have a couple warnings still, but I'll come back to them later.\n\nAt this point we should have an `a.out` present as our compiled artifact. If so, we can proceed to getting ready to flash this thing.\n\n### avrdude\n\nFor starters, we're going to leverage `avrdude` here, specifically something akin to:\n```\navrdude -p ? -c ? -P ?`\n```\nIt's full of question marks, because, well, I'm genuinely _not_ certain what we need to pass yet, so let's fill in the gaps.\n\nThe `-p` flag is used to specify the part number, which we need to lookup. We can do this quickly via `avrdude -p ?` to list all available parts (literal `?` here, not a placeholder). Note that on my setup working in zsh, I had to escape the `?` to avoid it being literally interpreted, just a small thing to keep in mind.\n\nGreping through with `attiny45` gave the following line:\n```\nt45        = ATtiny45, ATtiny45V (SPM, ISP, HVSP, debugWIRE)\n```\nWhich looks spot on! So `t45` is our part.\n\nThe `-c` flag tells us which programmer we intend to use. Much like the `-p` flag, we can run `avrdude -c ?` to list all available programmers.\n\nAnd honestly, at first glance I had _no idea_ which programmer to select. I vaguely remember having the same problem some years ago, so I flipped back through some of my old notes, and read that I was using `ft232r`, which corresponds to this entry:\n```\nft232r = FT232R based generic programmer (TPI, ISP)\n```\n\nThis turned up a huge blank in my mind at first, so I had to look it up. Turns out this was just a regular USB to Serial converter, with that particular chip being at the heart of it, which matches up.\n\nI also had a couple other AVR-based programmers that I wanted to try out this time around too. Specifically one unmarked programmer with an `ATMega8A AU 1801` and another marked as an `AVR Pocket Programmer` by Sparkfun with an `ATTiny2313-20SU` at the heart of it. The later was given to me by a friend from a while ago, but I never got to put it to use.\n\nSo looking it up a bit, I [found a product page](https://www.sparkfun.com/pocket-avr-programmer.html), and an [accompanying github project as well](https://github.com/sparkfun/Pocket_AVR_Programmer?tab=readme-ov-file). Through that, I found that `-c usbtiny` is the matching programmer field (makes sense given the ATTiny at the core). I also noted that it's got a nifty target board power feature. This lets the programmer also power the board with up to 500mA, meaning we don't have to power the board separately in addition to the programmer being hooked up. So at this point I decided to just stick with the `AVR Pocket Programmer`.\n\nThat left just the last flag `-P` for the port. Granted we don't quite have that yet until we plug in the device, so doing that and looking through `/dev` yielded....\n\nNothing, at least not at first. But before looking that up I wanted to double check that what we had so far was correct:\n```bash\navrdude -p t45 -c usbtiny\n```\n\nRunning that gave me the following:\n```\nError: cannot find USBtiny device (0x1781/0xc9f)\nError: unable to open port usb for programmer usbtiny\n```\n\nWhich looks pretty good for now, given we're not specifying the port yet.\n\nI also noted a _ton_ of warnings about an inability to locate expected data, ex. `Error: unable to locate ATxmega16A4U's data in multi-memory address space`. Looking it up suggested some issues with the installed AVR board package, and also with the configuration file itself. On my system, I was able to find several config files in various locations, and also I was able to feed them in via `-C other.conf`. This yielded fewer but more problematic errors, but at least seemed to suggest that perhaps the default configuration was the issue.\n\nMy installation was via homebrew, and looking that up didn't get me anywhere too quickly. Not wanting to get bogged down, I noted it here as I wanted to get along to the actual flashing.\n\nLooking at the programmer, the need thing we need to do is connect the dots. I wasn't terribly familiar with the pinout orientation, but it's laid out like so on the programmer I was using.\n```\nMISO |• •| VCC\nSCK  |• •| MOSI\nRST  |• •| GND\n```\n\nThe first step was verifying the orientation of VCC and GND with a multimeter, and once I had that the rest of the pins fell into place pretty nicely. It always helps to double check (or even triple check) your pins, as I often and _frequently_ end up with an off-by-one error with my wiring.\n\nAssuming that's all wired up and your programmer of choice is plugged in, you can hook everything up. One particular note about my programmer was about the board power capability. I wanted this off at first (although I soon realized a mistake with that), but later on it could be particularly problematic given it's fixed at 5v power only. If there was anything wired up to VCC expecting 3.3v, that could cause some problems. I had a few logic level converters lying around, but for now I just keep this potential issue in mind, as it wasn't a factor yet.\n\nSo, plugging in the programmer, I finally checked out the list under `/dev`, but upon further inspection realized that's not really needed, as `avrdude` _should_ pick up the attached programmer automatically (although later I did add `-P usb`).\n\nIn my case I did get a different response with the programmer connected to my computer, but it was an error:\n```\navrdude -p t45 -c usbtiny\n...\n\nError: initialization failed  (rc = -1)\n - double check the connections and try again\n - use -B to set lower the bit clock frequency, e.g. -B 125kHz\n - use -F to override this check\n```\n\nI ran again with a suggested change to the clock frequency, but got the same error. So I changed up how I connected the programmer to my computer, as it was going through a bit of overhead via a USB hub & extra cabling. Running directly attached I still got the same error, which appeared to rule the hub out.\n\nI dove back into the docs, and tried to figure out the issue from there (while not ruling out the old programmer quite yet, as it had been sitting in a box for quite some years). I wasn't able to get too far, but I _was_ expecting to at leas see a device entry pop up in `/dev` but never got that. This was rather suspicious, although it did seem that despite this `avrdude` was picking up that there was _something_ connected. I assumed I must have missed a detail there or just didn't understand what was going on yet.\n\nTo avoid spending too much time on the one programmer, I decided to try out the other programmers I had, without connecting to the ATTiny45, just to see if there was a difference when flashing. The other ATMega based programmer I had seemed to have a similar issue, but the FT232R based programmer _did_ register as a new entry in `/dev`, which matched up with what I was expecting. That gave me some sense that I could probably use that programmer to proceed, but now I was curious why the others weren't working as expected, so I dug further into that. Later on I would figure out that the FT232R programmer was definitely _not_ the right choice.\n\nBased on what I came across, not seeing a USBTiny device in `/dev` was actually expected, but I didn't understand why at first. Apparently this is due to not populating a new device entry. I'm not familiar enough to do more than speculate, but it appears to be related to how it communicates via `libusb`, but I could be wrong here. Establishing this at least alleviated my concern that the problem was from the missing device, and helped me to get a sense of why `avrdude` was indicating a device was present even when I couldn't confirm it myself. Still, none of this got to me flashing the microcontroller successfully.\n\nAt this point I got super stuck, and it was late, so I read up on things & tinkered for a bit before wrapping up for the day.\n\n<!-- - FT232R is not the right choice (that's UART, not SPI, which is COPI/CIPO)\n- Arduino nano as programmer seems viable as well... -->\n\n<!-- So after much digging & such, I decided to shift to using an Arduino as ISP, with a pair of Nanos I had lying around. One was viable, but the other was locked up due to something I had loaded on it years ago. I figured a good way to test ISP capability was to try and reset that other board (if it could be done). So I wired them up and gave it a shot after loading the first board with the ArduinoISP sketch.\n\nHowever, after much testing, I was still nowhere closer to a solution. So I took a break and stepped away for a day or so. -->\n\n### Coming back to it\n\nThe following day I read up quite a bit more about programming ATTiny's in general, and especially about some of the 'gotchas' that tend to come up. For the most part, it seems like it shouldn't have been a driver issue (but that can be investigated with another machine), and I didn't believe I messed up the pin connections (hopefully). I did have a hunch that my wires (via dupont connectors) maybe weren't as good as thought they were. That, or the micrcontroller itself was possibly damaged.\n\nI was able to test with another microcontroller to see if that was a factor, and I got a similar response at first, but later made a bit of progress:\n```\nAVR device initialized and ready to accept instructions\nDevice signature = 00 00 00 (retrying)\nDevice signature = 00 00 00 (retrying)\nDevice signature = 00 00 00\nError: invalid device signature\nError: expected signature for ATtiny45 is 1E 92 06\n  - double check connections and try again, or use -F to carry on regardless\n```\n\nThis was better than before at least, but still not a success (not yet).\n\nWell after rewiring back to the AVR Pocker Programmer a second time around, I was able to get the device to connect correctly, and program with a flashing light! Finally.\n\nAfter double checking a few things, I was able to isolate it down to the power feature being set to 'off'. I was under the impression that, since I was reading voltage around ~4.7 volts on VCC, it was sufficient to allow programming to happen. _But_, it seems that although I was reading this voltage via a multimeter, I wasn't actually sending sufficient power to flash the chip. Honestly, I'm not sure yet, but I'm keeping it as an open point to investigate in more detail later on. For now having the chip flashed was a good enough spot to stop on.\n\nJust for good measure I ran the same flash sequence on another ATTiny45 I had lying around, and it was a success as well. 2 for 2!\n\nI had also tried out an Arduino Nano as an ISP programmer while I was debugging things. I suspect if I switched back to the Arduino Nano as an ISP I would be able to get a similar result as well, assuming that the chip was powered up during the flashing process like before.\n\nSo with all that we should have a simple program flashed & running on the ATTiny, but not much more than that. However with this we can focus on actually writing up & testing programs, with the next step being to have some monitoring to diagnose problems as they arise.",
    "frontmatter": {
      "title": "Getting Started Developing for the ATTiny13 & 45",
      "date": "2026-02-14",
      "tags": "[attiny, post, project]",
      "excerpt": "Getting started with writing & flashing to an ATTiny 13 & 45 microcontroller.",
      "draft": "false"
    }
  }
]

export function getPost(slug) {
  return posts.find(post => post.slug === slug)
}

export function getAllPosts() {
  return posts
}
